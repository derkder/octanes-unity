游戏中状态机就是一个对象或者角色，有多种状态属性，多种状态下切换变化，比如走路，1段跳跃，2段跳跃，战斗，死亡这些状态。
根据当前是什么状态下可以切换到什么状态，比如走路的时候我可以切换到1段跳跃。在1段跳跃下才能做2段跳。
简单的有限状态机可以用枚举+switch的方式实现，用Switch语句来获取状态，并且通过特定的方法来设置状态。但我们可能要在项目的很多地方的调用这段Switch方法，或者设置当前人物的状态。
状态机是一种网络结构。它比较符合我们的常规思维，也比较直观。用于做一些简单的AI没什么大问题。(比如走路的时候搜索敌人，发现敌人，对敌人进行攻击，敌人死亡)用状态机其实更加便捷。
但是如果AI比较复杂的话，比如它的状态比较多的话，就显的比较复杂。我们用一张网络（如下面的图）表示，如果状态就几个的话，逻辑上就可控，一旦多起来的话，维护的状态量就会成倍的增加，导致代码上写的很繁琐吃力。
缺点：
1.状态机总是在某一状态中，不能执行多个状态的事情，
      解决：设置多层状态机同时运行解决这个问题
2.不易于拓展，新的逻辑需要新的状态。
      解决：在状态运行多个小Action，复用Aciton，但Action会变得细碎



行为树的实现：Behavior Designer是Unity制作行为树的一个插件，它的主要作用并非可以不写代码（还是要写不少代码的），而是能让游戏中逻辑最混乱的模块——AI模块能更有序的组织，方便查看、调试和修改。
行为树就是一个包含逻辑节点和行为节点的树结构体，我们把每一种情况都抽象成一个类型的节点，然后我们按照这个规范去写节点，然后把这些节点连接成一棵树。
//！！！！！我们每次去找一个行为是时候，就会从树的跟节点出发。遍历各个节点，寻找出一个和当前数据相符合的行为。比如我们有一个士兵有无怪物的时候巡逻，
视野内有小怪的时候攻击，视野内看到大BOSS逃跑三个行为。我们就在程序中找到这个英雄，让从左到右遍历自己的子节点，如果子节点的准入条件符合信息的话，就执行该子节点。！！！！//
https://blog.csdn.net/q50736006/article/details/118612046

